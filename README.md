# netology_12-6

# Домашнее задание к занятию «Репликация и масштабирование. Часть 1»

## Задание 1

На лекции рассматривались режимы репликации master-slave, master-master, опишите их различия.  
Ответить в свободной форме.

## Решение 1

Репликация Master-Slave — это способ организации базы данных, где есть один главный сервер (Master) и один или несколько подчинённых (Slave). Master принимает все запросы на запись (добавление, изменение, удаление данных), а Slaves только читают данные и получают обновления от Master.  

Как это работает?
1.	Клиенты записывают данные только в Master.
2.	Master автоматически передаёт изменения Slaves.
3.	Клиенты могут читать данные как с Master, так и с Slaves (чаще читают со Slaves, чтобы снизить нагрузку на Master).  

Плюсы:  
* Разгрузка Master — чтение можно распределить по нескольким Slaves, что повышает производительность.
* Резервирование — если Master сломается, можно переключиться на один из Slaves.
* Масштабируемость — можно добавлять новые Slaves без перегрузки основного сервера.  

Минусы:  
* Задержка синхронизации — данные на Slaves могут немного отставать от Master.
* Если Master падает, вручную или с помощью дополнительных механизмов нужно выбрать нового. Необходимо предусмотреть сценарий и алгоритм, при котором Slaves узлы самостоятельно выберут нового Master среди себя.
* Не подходит для интенсивной записи — так как записи идут только в один узел, он может стать узким местом.

Где используется:
* Используется, когда нужно выполнять много операций чтения, но немного операций записи. 
* Например, в веб-сайтах электронной коммерции, где slave-серверы выполняют тяжёлые операции чтения списка товаров, а master-сервер — операции записи (обработку заказов). 
* Также такая модель применяется в системах управления контентом, где операции чтения распределяются между несколькими slave-серверами, а master-сервер управляет обновлениями и изменениями содержимого. 

Репликация Master-Master — это когда у базы данных есть два (или больше) главных сервера, и каждый из них может одновременно принимать и обрабатывать запросы на запись и чтение. Данные между серверами автоматически синхронизируются, чтобы оставаться одинаковыми.

Плюсы:
* Высокая отказоустойчивость — если один сервер выходит из строя, другой продолжает работать.
* Балансировка нагрузки — можно распределять запросы между серверами, снижая нагрузку на каждый из них.
* Быстрее для географически распределенных систем — пользователи могут работать с ближайшим сервером, уменьшая задержки.

Минусы:
* Конфликты данных — если два сервера изменяют одни и те же данные одновременно, могут возникнуть проблемы с их синхронизацией. Главной задачей разработчика системы станет гарантировать согласованность данных, что по CAP теореме повлечет снижение Доступности или Готовности к разрыву сети.
* Сложность настройки и поддержки — требуется механизм разрешения конфликтов и контроль синхронизации.
* Задержки репликации — хотя данные синхронизируются, это не всегда происходит мгновенно, что может привести к временным рассинхронизациям.

Где используется:
* Используется там, где нужно писать много данных. 
* Например, на сайтах социальных сетей, где новые сообщения нужно записывать в базу данных и непрерывно читать из неё, чтобы отображать в ленте пользователя. 

Таким образом, выбор между репликациями Master-Slave и Master-Master зависит от конкретных требований и задач системы.

## Задание 2

Выполните конфигурацию master-slave репликации, примером можно пользоваться из лекции.  
Приложите скриншоты конфигурации, выполнения работы: состояния и режимы работы серверов.

## Решение 2

Запуск базы mysql в docker compose.
```
sudo docker compose up -d
```
![](https://github.com/eskin-igor/netology_12-6/blob/main/12-6/12-5-2-0.JPG)

Статус сервера Master.
```
SHOW MASTER STATUS;
```
![](https://github.com/eskin-igor/netology_12-6/blob/main/12-6/12-5-2-1.JPG)

Статус сервера Slave.
```
SHOW SLAVE STATUS;
SHOW REPLICA STATUS;
```
![](https://github.com/eskin-igor/netology_12-6/blob/main/12-6/12-5-2-2.JPG)
![](https://github.com/eskin-igor/netology_12-6/blob/main/12-6/12-5-2-3.JPG)

У меня в статусе сервера Slave появилась ошибка - Fatal error: The replica I/O thread stops because source and replica have equal MySQL server ids.
Эта ошибка может появилась потому чтоу  Master-сервера и Slave-сервера одинаковые номера server_id. Причем в конфигурационных файлах указанны явно разные id.
Для исправления этой ошибки подключаемся к Slave-серверу и зайдём в mysql.
```
sudo docker exec -it mysql-slave /bin/bash 
mysql -u root –p
```
![](https://github.com/eskin-igor/netology_12-6/blob/main/12-6/12-5-2-4.JPG)

```
show variables like 'server_id';
```
У меня на Slave-сервере вывод был следующим:
```
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| server_id     | 1     |
+---------------+-------+
1 row in set (0,01 sec)
```
Хотя в конфигурационном файле значения server_id стояло 2.  
Чтобы исправить данную ошибку вводим следующие команды:
```
STOP SLAVE;
set global server_id=2;
START SLAVE;
```
Теперь проверим вывод команды:
```
show variables like 'server_id';
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| server_id     | 2     |
+---------------+-------+
```
![](https://github.com/eskin-igor/netology_12-6/blob/main/12-6/12-5-2-5.JPG)

Теперь статус сервера Slave выглядит следующим образом.

![](https://github.com/eskin-igor/netology_12-6/blob/main/12-6/12-5-2-6.JPG)
![](https://github.com/eskin-igor/netology_12-6/blob/main/12-6/12-5-2-7.JPG)

На сервере Master создадим новую базу данных – DB_test.  
И запишем данные.

![](https://github.com/eskin-igor/netology_12-6/blob/main/12-6/12-5-2-8.JPG)

Обновим базу сервера Slave.   
И увидим те же данные в реплицированной базе.

![](https://github.com/eskin-igor/netology_12-6/blob/main/12-6/12-5-2-9.JPG)

Если удалить тестовую базу с сервера Master, то тестовая база также удалится и с сервера Slave.

![](https://github.com/eskin-igor/netology_12-6/blob/main/12-6/12-5-2-10.JPG)
